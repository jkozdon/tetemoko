C
C       Return the maximum wave speed, which is just the max of cs and cp
C
        subroutine MAXWAVESPEEDF(
     &    CHF_REAL[cmax],
     &    CHF_CONST_FRA[U],
     &    CHF_BOX[box])

#include "IBCCommon.fh"

        cmax = max(cs,cp)
CLIN    cmax = cp

        return
        end


C
C       Compute the magnitude of the fields
C       THIS IS CHOMBO CODE
C
        subroutine MAGNITUDEF(
     &    CHF_FRA1[magdata],
     &    CHF_CONST_FRA[data],
     &    CHF_BOX[box])

        integer CHF_DDECL[i;j;k]
        integer iv
        real_t cur,sum

        CHF_MULTIDO[box;i;j;k]
          sum = zero

c
c         Compute sum over all directions (x,y,z)
c
          do iv = 0,CHF_NCOMP[data]-1
            cur = data(CHF_IX[i;j;k],iv)
            sum = sum + cur*cur
          enddo

          magdata(CHF_IX[i;j;k]) = sqrt(sum)
        CHF_ENDDO

        return
        end


C
C       Compute the magnitude of the fields
C       THIS IS CHOMBO CODE
C
        subroutine MAXF(
     &    CHF_FRA1[magdata],
     &    CHF_CONST_FRA[data],
     &    CHF_BOX[box])

        integer CHF_DDECL[i;j;k]
        integer iv
        real_t cur

        CHF_MULTIDO[box;i;j;k]
          cur = zero

c
c         Compute sum over all directions (x,y,z)
c
          do iv = 0,CHF_NCOMP[data]-1
            cur = max(cur,abs(data(CHF_IX[i;j;k],iv)))
          enddo

          magdata(CHF_IX[i;j;k]) = cur
        CHF_ENDDO

        return
        end

C
C       Compute the relative gradient
C       difference / average in each direction
C       THIS IS CHOMBO CODE
C
        subroutine GETRELGRADF(
     &    CHF_FRA1[du],
     &    CHF_CONST_FRA1[u],
     &    CHF_CONST_INT[idir],
     &    CHF_BOX[loBox],
     &    CHF_CONST_INT[hasLo],
     &    CHF_BOX[hiBox],
     &    CHF_CONST_INT[hasHi],
     &    CHF_BOX[centerBox])

        integer CHF_DDECL[i   ;j   ;k   ]
        integer CHF_DDECL[ioff;joff;koff]
        real_t diff,aver

        CHF_DTERM[
        ioff = CHF_ID(0,idir);
        joff = CHF_ID(1,idir);
        koff = CHF_ID(2,idir)]

c       Perform first difference calculation in the interior.
c       Centered difference / Average

        CHF_MULTIDO[centerBox;i;j;k]
          diff = half*(u(CHF_IX[i+ioff;j+joff;k+koff])
     &                -u(CHF_IX[i-ioff;j-joff;k-koff]))
          aver = half*(u(CHF_IX[i+ioff;j+joff;k+koff])
     &                +u(CHF_IX[i-ioff;j-joff;k-koff]))
          du(CHF_IX[i;j;k]) = diff / aver
        CHF_ENDDO

c       Perform calculation on the cells adjacent to the domain boundary in
c       current direction, if required.

        if (hasLo .eq. 1) then
          CHF_MULTIDO[loBox;i;j;k]
            diff = (u(CHF_IX[i+ioff;j+joff;k+koff])
     &             -u(CHF_IX[i     ;j     ;k     ]))
            aver = half*(u(CHF_IX[i+ioff;j+joff;k+koff])
     &                  +u(CHF_IX[i     ;j     ;k     ]))
            du(CHF_IX[i;j;k]) = diff / aver
          CHF_ENDDO
        endif

        if (hasHi .eq. 1) then
          CHF_MULTIDO[hiBox;i;j;k]
            diff = (u(CHF_IX[i     ;j     ;k     ])
     &             -u(CHF_IX[i-ioff;j-joff;k-koff]))
            aver = half*(u(CHF_IX[i     ;j     ;k     ])
     &                  +u(CHF_IX[i-ioff;j-joff;k-koff]))
            du(CHF_IX[i;j;k]) = diff / aver
          CHF_ENDDO
        endif

        return
        end
C
C       Mark cells on boundary for refinement
C
        subroutine BOUNDREFINE(
     &    CHF_FRA1[markCells],
     &    CHF_CONST_REAL[refLocation],
     &    CHF_CONST_REAL[dx],
     &    CHF_BOX[box])

        integer CHF_DDECL[i   ;j   ;k   ]

        CHF_MULTIDO[box;i;j;k]
          if(j .eq. 0
          CHF_DTERM[
     &       .and. ((i + 1) * dx) .ge. refLocation 
     &       .and. ((i    ) * dx) .le. refLocation;;
     &       .and. ((k + 1) * dx) .ge. refLocation 
     &       .and. ((k    ) * dx) .le. refLocation]) then

              markCells(CHF_IX[i;j;k]) = 1

          else

              markCells(CHF_IX[i;j;k]) = -1

          endif
        CHF_ENDDO

        end


C
C       Compute the absolution gradient and several components
C       THIS IS CHOMBO CODE
C
        subroutine GETFULLGRADF(
     &    CHF_FRA1[du],
     &    CHF_CONST_FRA[u],
     &    CHF_CONST_INT[idir],
     &    CHF_BOX[loBox],
     &    CHF_CONST_INT[hasLo],
     &    CHF_BOX[hiBox],
     &    CHF_CONST_INT[hasHi],
     &    CHF_BOX[centerBox])


        integer CHF_DDECL[i   ;j   ;k   ]
        integer CHF_DDECL[ioff;joff;koff]
        integer iv
        real_t diff

        CHF_DTERM[
        ioff = CHF_ID(0,idir);
        joff = CHF_ID(1,idir);
        koff = CHF_ID(2,idir)]


c       Perform first difference calculation in the interior.

        CHF_MULTIDO[centerBox;i;j;k]
          diff = 0.0d0
          do iv = 0,2
            diff = max(diff,half*abs(u(CHF_IX[i+ioff;j+joff;k+koff],iv)
     &                              -u(CHF_IX[i-ioff;j-joff;k-koff],iv)))

          enddo
          du(CHF_IX[i;j;k]) = diff
        CHF_ENDDO

c       Perform calculation on the cells adjacent to the domain boundary in
c       current direction, if required.

        if (hasLo .eq. 1) then
          CHF_MULTIDO[loBox;i;j;k]
            diff = 0.0d0
            do iv = 0,2
              diff = max(diff,abs(u(CHF_IX[i+ioff;j+joff;k+koff],iv)
     &                           -u(CHF_IX[i     ;j     ;k     ],iv)))
            enddo
            du(CHF_IX[i;j;k]) = diff
          CHF_ENDDO
        endif

        if (hasHi .eq. 1) then
          CHF_MULTIDO[hiBox;i;j;k]
            diff = 0.0d0
            do iv = 0,2
              diff = max(diff,abs(u(CHF_IX[i     ;j     ;k     ],iv)
     &                           -u(CHF_IX[i-ioff;j-joff;k-koff],iv)))
            enddo
            du(CHF_IX[i;j;k]) = diff
          CHF_ENDDO
        endif

        return
        end

C
C       Compute the flux from the physical variables
C       THIS IS MODIFIED CHOMBO CODE
C
        subroutine GETFLUXF(
     &    CHF_FRA[F],
     &    CHF_CONST_FRA[Wgdnv],
     &    CHF_CONST_INT[idir],
     &    CHF_BOX[box])

#include "IBCCommon.fh"

        integer CHF_DDECL[i     ;j     ;k    ]
        real_t  vx, vy, vz, sxx, syy, szz, sxy, sxz, syz, rv

        integer cx,cy,cz,cxy,cxz,cyz

        cx = idir
        cy = mod(idir+1,3)
        cz = mod(idir+2,3)

        ! rv tracks which direction the characteristics propagate on
        ! side 2 of the fault (only flipped for the y direction which is
        ! mirrored)
        if (idir .eq. 0) then
          cxy = 6
          cxz = 7
          cyz = 8
          rv  = 1d0
        else if (idir .eq. 1) then
          cxy = 8
          cxz = 6
          cyz = 7
          rv  =-1d0
          !rv  = 1d0
        else
          cxy = 7
          cxz = 8
          cyz = 6
          rv  = 1d0
        endif

        CHF_MULTIDO[box;i;j;k]
        ! Side 1
          vx  = Wgdnv(CHF_IX[i;j;k],cx    )
          vy  = Wgdnv(CHF_IX[i;j;k],cy    )
          vz  = Wgdnv(CHF_IX[i;j;k],cz    )
          sxx = Wgdnv(CHF_IX[i;j;k],cx + 3)
          syy = Wgdnv(CHF_IX[i;j;k],cy + 3)
          szz = Wgdnv(CHF_IX[i;j;k],cz + 3)
          sxy = Wgdnv(CHF_IX[i;j;k],cxy   )
          sxz = Wgdnv(CHF_IX[i;j;k],cxz   )
          syz = Wgdnv(CHF_IX[i;j;k],cyz   )

          F(CHF_IX[i;j;k],cx    ) = -sxx / rho
          F(CHF_IX[i;j;k],cy    ) = -sxy / rho
          F(CHF_IX[i;j;k],cz    ) = -sxz / rho
          F(CHF_IX[i;j;k],cx + 3) = -vx * (lam + two * mu)
          F(CHF_IX[i;j;k],cy + 3) = -vx * lam
          F(CHF_IX[i;j;k],cz + 3) = -vx * lam
          F(CHF_IX[i;j;k],cxy   ) = -vy * mu
          F(CHF_IX[i;j;k],cxz   ) = -vz * mu
          F(CHF_IX[i;j;k],cyz   ) =  0d0
          F(CHF_IX[i;j;k], 9    ) =  0d0
          F(CHF_IX[i;j;k],10    ) =  0d0

        ! Side 2
          vx  = Wgdnv(CHF_IX[i;j;k],11 + cx    )
          vy  = Wgdnv(CHF_IX[i;j;k],11 + cy    )
          vz  = Wgdnv(CHF_IX[i;j;k],11 + cz    )
          sxx = Wgdnv(CHF_IX[i;j;k],11 + cx + 3)
          syy = Wgdnv(CHF_IX[i;j;k],11 + cy + 3)
          szz = Wgdnv(CHF_IX[i;j;k],11 + cz + 3)
          sxy = Wgdnv(CHF_IX[i;j;k],11 + cxy   )
          sxz = Wgdnv(CHF_IX[i;j;k],11 + cxz   )
          syz = Wgdnv(CHF_IX[i;j;k],11 + cyz   )

          F(CHF_IX[i;j;k],11 + cx    ) = - rv * sxx / rho
          F(CHF_IX[i;j;k],11 + cy    ) = - rv * sxy / rho
          F(CHF_IX[i;j;k],11 + cz    ) = - rv * sxz / rho
          F(CHF_IX[i;j;k],11 + cx + 3) = - rv * vx * (lam + two * mu)
          F(CHF_IX[i;j;k],11 + cy + 3) = - rv * vx * lam
          F(CHF_IX[i;j;k],11 + cz + 3) = - rv * vx * lam
          F(CHF_IX[i;j;k],11 + cxy   ) = - rv * vy * mu
          F(CHF_IX[i;j;k],11 + cxz   ) = - rv * vz * mu
          F(CHF_IX[i;j;k],11 + cyz   ) =  0d0
          F(CHF_IX[i;j;k],11 +  9    ) =  0d0
          F(CHF_IX[i;j;k],11 + 10    ) =  0d0

        CHF_ENDDO

        return
        end

C
C       Convert to characteristic variables
C       assumes cp >= cs
C
        subroutine CHARANALYSISF(
     &    CHF_FRA[dW],
     &    CHF_CONST_FRA[W],
     &    CHF_CONST_INT[idir],
     &    CHF_BOX[box])

#include "IBCCommon.fh"

        real_t  vx1, vy1, vz1, sxx1, syy1, szz1, sxy1, sxz1, syz1, lam1, gam1
        real_t  vx2, vy2, vz2, sxx2, syy2, szz2, sxy2, sxz2, syz2, lam2, gam2
        real_t  rv

        integer CHF_DDECL[i;j;k]
        integer cx,cy,cz,cxy,cxz,cyz

        cx = idir
        cy = mod(idir+1,3)
        cz = mod(idir+2,3)

        if (idir .eq. 0) then
          cxy = 6
          cxz = 7
          cyz = 8
          rv  = 1d0
        else if (idir .eq. 1) then
          cxy = 8
          cxz = 6
          cyz = 7
          rv  =-1d0
          !rv  = 1d0
        else
          cxy = 7
          cxz = 8
          cyz = 6
          rv  = 1d0
        endif

        CHF_MULTIDO[box;i;j;k]
          ! Side 1
          vx1  = dW(CHF_IX[i;j;k],cx    )
          vy1  = dW(CHF_IX[i;j;k],cy    )
          vz1  = dW(CHF_IX[i;j;k],cz    )
          sxx1 = dW(CHF_IX[i;j;k],cx + 3)
          syy1 = dW(CHF_IX[i;j;k],cy + 3)
          szz1 = dW(CHF_IX[i;j;k],cz + 3)
          sxy1 = dW(CHF_IX[i;j;k],cxy   )
          sxz1 = dW(CHF_IX[i;j;k],cxz   )
          syz1 = dW(CHF_IX[i;j;k],cyz   )
          lam1 = dW(CHF_IX[i;j;k], 9    )
          gam1 = dW(CHF_IX[i;j;k],10    )

          ! Side 2
          vx2  = rv*dW(CHF_IX[i;j;k],11 + cx    )
          vy2  = rv*dW(CHF_IX[i;j;k],11 + cy    )
          vz2  = rv*dW(CHF_IX[i;j;k],11 + cz    )
          sxx2 =    dW(CHF_IX[i;j;k],11 + cx + 3)
          syy2 =    dW(CHF_IX[i;j;k],11 + cy + 3)
          szz2 =    dW(CHF_IX[i;j;k],11 + cz + 3)
          sxy2 =    dW(CHF_IX[i;j;k],11 + cxy   )
          sxz2 =    dW(CHF_IX[i;j;k],11 + cxz   )
          syz2 =    dW(CHF_IX[i;j;k],11 + cyz   )
          lam2 =    dW(CHF_IX[i;j;k],11 +  9    )
          gam2 =    dW(CHF_IX[i;j;k],11 + 10    )

          ! Side 2
          dW(CHF_IX[i;j;k],2* 0) = sxx1 + vx1  * Zp
          dW(CHF_IX[i;j;k],2* 1) = sxy1 + vy1  * Zs
          dW(CHF_IX[i;j;k],2* 2) = sxz1 + vz1  * Zs
          dW(CHF_IX[i;j;k],2* 3) = syy1 - sxx1 * lam / (2.0d0 * mu + lam)
          dW(CHF_IX[i;j;k],2* 4) = szz1 - sxx1 * lam / (2.0d0 * mu + lam)
          dW(CHF_IX[i;j;k],2* 5) = syz1
          dW(CHF_IX[i;j;k],2* 6) = lam1
          dW(CHF_IX[i;j;k],2* 7) = gam1
          dW(CHF_IX[i;j;k],2* 8) = sxz1 - vz1 * Zs
          dW(CHF_IX[i;j;k],2* 9) = sxy1 - vy1 * Zs
          dW(CHF_IX[i;j;k],2*10) = sxx1 - vx1 * Zp

          ! Side 2
          dW(CHF_IX[i;j;k],1 + 2* 0) = sxx2 + vx2  * Zp
          dW(CHF_IX[i;j;k],1 + 2* 1) = sxy2 + vy2  * Zs
          dW(CHF_IX[i;j;k],1 + 2* 2) = sxz2 + vz2  * Zs
          dW(CHF_IX[i;j;k],1 + 2* 3) = syy2 - sxx2 * lam / (2.0d0 * mu + lam)
          dW(CHF_IX[i;j;k],1 + 2* 4) = szz2 - sxx2 * lam / (2.0d0 * mu + lam)
          dW(CHF_IX[i;j;k],1 + 2* 5) = syz2
          dW(CHF_IX[i;j;k],1 + 2* 6) = lam2
          dW(CHF_IX[i;j;k],1 + 2* 7) = gam2
          dW(CHF_IX[i;j;k],1 + 2* 8) = sxz2 - vz2 * Zs
          dW(CHF_IX[i;j;k],1 + 2* 9) = sxy2 - vy2 * Zs
          dW(CHF_IX[i;j;k],1 + 2*10) = sxx2 - vx2 * Zp
        CHF_ENDDO


        return
        end

C
C       Convert to physical variables
C       assumes cp >= cs
C
        subroutine CHARSYNTHESISF(
     &    CHF_FRA[dW],
     &    CHF_CONST_FRA[W],
     &    CHF_CONST_INT[idir],
     &    CHF_BOX[box])

#include "IBCCommon.fh"

        real_t  wxxp1, wxxm1, wxyp1, wxym1, wxzp1, wxzm1, wyy1, wzz1, wyz1, sxx1, lam1, gam1
        real_t  wxxp2, wxxm2, wxyp2, wxym2, wxzp2, wxzm2, wyy2, wzz2, wyz2, sxx2, lam2, gam2
        real_t rv

        integer CHF_DDECL[i;j;k]
        integer cx,cy,cz,cxy,cxz,cyz

        cx = idir
        cy = mod(idir+1,3)
        cz = mod(idir+2,3)

        if (idir .eq. 0) then
          cxy = 6
          cxz = 7
          cyz = 8
          rv  = 1d0
        else if (idir .eq. 1) then
          cxy = 8
          cxz = 6
          cyz = 7
          rv  =-1d0
          !rv  = 1d0
        else
          cxy = 7
          cxz = 8
          cyz = 6
          rv  = 1d0
        endif

        CHF_MULTIDO[box;i;j;k]
          ! Side 1
          wxxm1 = dW(CHF_IX[i;j;k],2* 0)
          wxym1 = dW(CHF_IX[i;j;k],2* 1)
          wxzm1 = dW(CHF_IX[i;j;k],2* 2)
          wyy1  = dW(CHF_IX[i;j;k],2* 3)
          wzz1  = dW(CHF_IX[i;j;k],2* 4)
          wyz1  = dW(CHF_IX[i;j;k],2* 5)
          lam1  = dW(CHF_IX[i;j;k],2* 6)
          gam1  = dW(CHF_IX[i;j;k],2* 7)
          wxzp1 = dW(CHF_IX[i;j;k],2* 8)
          wxyp1 = dW(CHF_IX[i;j;k],2* 9)
          wxxp1 = dW(CHF_IX[i;j;k],2*10)

          sxx1 = (wxxm1 + wxxp1) / 2.0d0

          ! Side 2
          wxxm2 = dW(CHF_IX[i;j;k],1 + 2* 0)
          wxym2 = dW(CHF_IX[i;j;k],1 + 2* 1)
          wxzm2 = dW(CHF_IX[i;j;k],1 + 2* 2)
          wyy2  = dW(CHF_IX[i;j;k],1 + 2* 3)
          wzz2  = dW(CHF_IX[i;j;k],1 + 2* 4)
          wyz2  = dW(CHF_IX[i;j;k],1 + 2* 5)
          lam2  = dW(CHF_IX[i;j;k],1 + 2* 6)
          gam2  = dW(CHF_IX[i;j;k],1 + 2* 7)
          wxzp2 = dW(CHF_IX[i;j;k],1 + 2* 8)
          wxyp2 = dW(CHF_IX[i;j;k],1 + 2* 9)
          wxxp2 = dW(CHF_IX[i;j;k],1 + 2*10)

          sxx2 = (wxxm2 + wxxp2) / 2.0d0

          ! Side 1
          dW(CHF_IX[i;j;k],cx    ) = (wxxm1 - wxxp1) / 2.0d0 / Zp
          dW(CHF_IX[i;j;k],cy    ) = (wxym1 - wxyp1) / 2.0d0 / Zs
          dW(CHF_IX[i;j;k],cz    ) = (wxzm1 - wxzp1) / 2.0d0 / Zs
          dW(CHF_IX[i;j;k],cx + 3) =  sxx1
          dW(CHF_IX[i;j;k],cy + 3) =  wyy1  + sxx1 * lam / (2.0d0 * mu + lam)
          dW(CHF_IX[i;j;k],cz + 3) =  wzz1  + sxx1 * lam / (2.0d0 * mu + lam)
          dW(CHF_IX[i;j;k],cxy   ) = (wxym1 + wxyp1) / 2.0d0
          dW(CHF_IX[i;j;k],cxz   ) = (wxzm1 + wxzp1) / 2.0d0
          dW(CHF_IX[i;j;k],cyz   ) =  wyz1
          dW(CHF_IX[i;j;k], 9    ) =  lam1
          dW(CHF_IX[i;j;k],10    ) =  gam1

          ! Side 2
          dW(CHF_IX[i;j;k],11 + cx    ) = rv * (wxxm2 - wxxp2) / 2.0d0 / Zp
          dW(CHF_IX[i;j;k],11 + cy    ) = rv * (wxym2 - wxyp2) / 2.0d0 / Zs
          dW(CHF_IX[i;j;k],11 + cz    ) = rv * (wxzm2 - wxzp2) / 2.0d0 / Zs
          dW(CHF_IX[i;j;k],11 + cx + 3) =  sxx2
          dW(CHF_IX[i;j;k],11 + cy + 3) =  wyy2  + sxx2 * lam / (2.0d0 * mu + lam)
          dW(CHF_IX[i;j;k],11 + cz + 3) =  wzz2  + sxx2 * lam / (2.0d0 * mu + lam)
          dW(CHF_IX[i;j;k],11 + cxy   ) = (wxym2 + wxyp2) / 2.0d0
          dW(CHF_IX[i;j;k],11 + cxz   ) = (wxzm2 + wxzp2) / 2.0d0
          dW(CHF_IX[i;j;k],11 + cyz   ) =  wyz2
          dW(CHF_IX[i;j;k],11 +  9    ) =  lam2
          dW(CHF_IX[i;j;k],11 + 10    ) =  gam2
        CHF_ENDDO


        return
        end


C
C       Return the eigenvalues, which for us are easy, in order low to high
C
        subroutine CHARVALUESF(
     &    CHF_FRA[lambda],
     &    CHF_BOX[box])
 
#include "IBCCommon.fh"
 
        integer CHF_DDECL[i;j;k]

        CHF_MULTIDO[box;i;j;k]
          ! lambda(CHF_IX[i;j;k],2*0) = -cp
          ! lambda(CHF_IX[i;j;k],2*1) = -cs
          ! lambda(CHF_IX[i;j;k],2*2) = -cs
          ! lambda(CHF_IX[i;j;k],2*3) =   0
          ! lambda(CHF_IX[i;j;k],2*4) =   0
          ! lambda(CHF_IX[i;j;k],2*5) =   0
          ! lambda(CHF_IX[i;j;k],2*6) =  cs
          ! lambda(CHF_IX[i;j;k],2*7) =  cs
          ! lambda(CHF_IX[i;j;k],2*8) =  cp

          ! lambda(CHF_IX[i;j;k],1+2*0) = -cp
          ! lambda(CHF_IX[i;j;k],1+2*1) = -cs
          ! lambda(CHF_IX[i;j;k],1+2*2) = -cs
          ! lambda(CHF_IX[i;j;k],1+2*3) =   0
          ! lambda(CHF_IX[i;j;k],1+2*4) =   0
          ! lambda(CHF_IX[i;j;k],1+2*5) =   0
          ! lambda(CHF_IX[i;j;k],1+2*6) =  cs
          ! lambda(CHF_IX[i;j;k],1+2*7) =  cs
          ! lambda(CHF_IX[i;j;k],1+2*8) =  cp
          lambda(CHF_IX[i;j;k], 0) = -cp
          lambda(CHF_IX[i;j;k], 1) = -cp
          lambda(CHF_IX[i;j;k], 2) = -cs
          lambda(CHF_IX[i;j;k], 3) = -cs
          lambda(CHF_IX[i;j;k], 4) = -cs
          lambda(CHF_IX[i;j;k], 5) = -cs
          lambda(CHF_IX[i;j;k], 6) = 0d0
          lambda(CHF_IX[i;j;k], 7) = 0d0
          lambda(CHF_IX[i;j;k], 8) = 0d0
          lambda(CHF_IX[i;j;k], 9) = 0d0
          lambda(CHF_IX[i;j;k],10) = 0d0
          lambda(CHF_IX[i;j;k],11) = 0d0
          lambda(CHF_IX[i;j;k],12) = 0d0
          lambda(CHF_IX[i;j;k],13) = 0d0
          lambda(CHF_IX[i;j;k],14) = 0d0
          lambda(CHF_IX[i;j;k],15) = 0d0
          lambda(CHF_IX[i;j;k],16) =  cs
          lambda(CHF_IX[i;j;k],17) =  cs
          lambda(CHF_IX[i;j;k],18) =  cs
          lambda(CHF_IX[i;j;k],19) =  cs
          lambda(CHF_IX[i;j;k],20) =  cp
          lambda(CHF_IX[i;j;k],21) =  cp
        CHF_ENDDO

        return
        end


C
C       Solve the Riemann problem
C       
        subroutine RIEMANNF(
     &    CHF_FRA[Wgdnv],
     &    CHF_CONST_FRA[WLeft],
     &    CHF_CONST_FRA[WRight],
     &    CHF_CONST_INT[idir],
     &    CHF_BOX[box])

#include "IBCCommon.fh"

        integer CHF_DDECL[i; j; k]

C       These are the average quantities
        real_t Rvx,Rvy,Rvz,Rsxx,Rsyy,Rszz,Rsxy,Rsxz,Rsyz,Rlam,Rgam
        real_t Lvx,Lvy,Lvz,Lsxx,Lsyy,Lszz,Lsxy,Lsxz,Lsyz,Llam,Lgam

C       These are the characteristic quanties
        real_t wxxp, wxxm, wxyp, wxym, wxzp, wxzm, wyy, wzz, wyz
        real_t sxx
        real_t rv

C       These coefficient and index
        real_t B
        integer cx,cy,cz,cxy,cxz,cyz

C       These permute the variables so we only need one loop
        cx = idir
        cy = mod(idir+1,3)
        cz = mod(idir+2,3)

        if (idir .eq. 0) then
          cxy = 6
          cxz = 7
          cyz = 8
          rv  = 1d0
        else if (idir .eq. 1) then
          cxy = 8
          cxz = 6
          cyz = 7
          rv  =-1d0
          !rv  = 1d0
        else
          cxy = 7
          cxz = 8
          cyz = 6
          rv  = 1d0
        endif

        CHF_MULTIDO[box;i;j;k]
          ! Side 1
C         Set the right state variables
          Rvx  = WRight(CHF_IX[i;j;k],cx    )
          Rvy  = WRight(CHF_IX[i;j;k],cy    )
          Rvz  = WRight(CHF_IX[i;j;k],cz    )
          Rsxx = WRight(CHF_IX[i;j;k],cx + 3)
          Rsyy = WRight(CHF_IX[i;j;k],cy + 3)
          Rszz = WRight(CHF_IX[i;j;k],cz + 3)
          Rsxy = WRight(CHF_IX[i;j;k],cxy   )
          Rsxz = WRight(CHF_IX[i;j;k],cxz   )
          Rsyz = WRight(CHF_IX[i;j;k],cyz   )
          Rlam = WRight(CHF_IX[i;j;k], 9    )
          Rgam = WRight(CHF_IX[i;j;k],10    )


C         Set the left state variables
          Lvx  = WLeft(CHF_IX[i;j;k],cx    )
          Lvy  = WLeft(CHF_IX[i;j;k],cy    )
          Lvz  = WLeft(CHF_IX[i;j;k],cz    )
          Lsxx = WLeft(CHF_IX[i;j;k],cx + 3)
          Lsyy = WLeft(CHF_IX[i;j;k],cy + 3)
          Lszz = WLeft(CHF_IX[i;j;k],cz + 3)
          Lsxy = WLeft(CHF_IX[i;j;k],cxy   )
          Lsxz = WLeft(CHF_IX[i;j;k],cxz   )
          Lsyz = WLeft(CHF_IX[i;j;k],cyz   )
          Llam = WLeft(CHF_IX[i;j;k], 9    )
          Lgam = WLeft(CHF_IX[i;j;k],10    )

          wxxp = Lsxx - Zp * Lvx
          wxyp = Lsxy - Zs * Lvy
          wxzp = Lsxz - Zs * Lvz

          wxxm = Rsxx + Zp * Rvx
          wxym = Rsxy + Zs * Rvy
          wxzm = Rsxz + Zs * Rvz

          wyy  = Rsyy - Rsxx * lam / (2.0d0 * mu + lam)
          wzz  = Rszz - Rsxx * lam / (2.0d0 * mu + lam)
          wyz  = Rsyz

          wyy  = (wyy + Lsyy - Lsxx * lam / (2.0d0 * mu + lam)) / 2.0d0
          wzz  = (wzz + Lszz - Lsxx * lam / (2.0d0 * mu + lam)) / 2.0d0
          wyz  = (wyz + Lsyz) / 2.0d0

          sxx = (wxxm + wxxp) / 2.0d0
          Wgdnv(CHF_IX[i;j;k],cx    ) = (wxxm - wxxp) / 2.0d0 / Zp
          Wgdnv(CHF_IX[i;j;k],cy    ) = (wxym - wxyp) / 2.0d0 / Zs
          Wgdnv(CHF_IX[i;j;k],cz    ) = (wxzm - wxzp) / 2.0d0 / Zs
          Wgdnv(CHF_IX[i;j;k],cx + 3) = (wxxm + wxxp) / 2.0d0
          Wgdnv(CHF_IX[i;j;k],cy + 3) =  wyy + sxx * lam / (2.0d0 * mu + lam)
          Wgdnv(CHF_IX[i;j;k],cz + 3) =  wzz + sxx * lam / (2.0d0 * mu + lam)
          Wgdnv(CHF_IX[i;j;k],cxy   ) = (wxym + wxyp) / 2.0d0
          Wgdnv(CHF_IX[i;j;k],cxz   ) = (wxzm + wxzp) / 2.0d0
          Wgdnv(CHF_IX[i;j;k],cyz   ) = wyz
          Wgdnv(CHF_IX[i;j;k], 9    ) = (Rlam + Llam) / 2.0d0
          Wgdnv(CHF_IX[i;j;k],10    ) = (Rgam + Lgam) / 2.0d0

          ! Side 2
C         Set the right state variables
          Rvx  = WRight(CHF_IX[i;j;k],11 + cx    )
          Rvy  = WRight(CHF_IX[i;j;k],11 + cy    )
          Rvz  = WRight(CHF_IX[i;j;k],11 + cz    )
          Rsxx = WRight(CHF_IX[i;j;k],11 + cx + 3)
          Rsyy = WRight(CHF_IX[i;j;k],11 + cy + 3)
          Rszz = WRight(CHF_IX[i;j;k],11 + cz + 3)
          Rsxy = WRight(CHF_IX[i;j;k],11 + cxy   )
          Rsxz = WRight(CHF_IX[i;j;k],11 + cxz   )
          Rsyz = WRight(CHF_IX[i;j;k],11 + cyz   )
          Rlam = WRight(CHF_IX[i;j;k],11 +  9    )
          Rgam = WRight(CHF_IX[i;j;k],11 + 10    )

C         Set the left state variables
          Lvx  = WLeft(CHF_IX[i;j;k],11 + cx    )
          Lvy  = WLeft(CHF_IX[i;j;k],11 + cy    )
          Lvz  = WLeft(CHF_IX[i;j;k],11 + cz    )
          Lsxx = WLeft(CHF_IX[i;j;k],11 + cx + 3)
          Lsyy = WLeft(CHF_IX[i;j;k],11 + cy + 3)
          Lszz = WLeft(CHF_IX[i;j;k],11 + cz + 3)
          Lsxy = WLeft(CHF_IX[i;j;k],11 + cxy   )
          Lsxz = WLeft(CHF_IX[i;j;k],11 + cxz   )
          Lsyz = WLeft(CHF_IX[i;j;k],11 + cyz   )
          Llam = WLeft(CHF_IX[i;j;k],11 +  9    )
          Lgam = WLeft(CHF_IX[i;j;k],11 + 10    )

          wxxp = Lsxx - rv*Zp * Lvx
          wxyp = Lsxy - rv*Zs * Lvy
          wxzp = Lsxz - rv*Zs * Lvz


          wxxm = Rsxx + rv*Zp * Rvx
          wxym = Rsxy + rv*Zs * Rvy
          wxzm = Rsxz + rv*Zs * Rvz

          wyy  = Rsyy - Rsxx * lam / (2.0d0 * mu + lam)
          wzz  = Rszz - Rsxx * lam / (2.0d0 * mu + lam)
          wyz  = Rsyz

          wyy  = (wyy + Lsyy - Lsxx * lam / (2.0d0 * mu + lam)) / 2.0d0
          wzz  = (wzz + Lszz - Lsxx * lam / (2.0d0 * mu + lam)) / 2.0d0
          wyz  = (wyz + Lsyz) / 2.0d0

          sxx = (wxxm + wxxp) / 2.0d0
          Wgdnv(CHF_IX[i;j;k],11 + cx    ) = rv*(wxxm - wxxp) / 2.0d0 / Zp
          Wgdnv(CHF_IX[i;j;k],11 + cy    ) = rv*(wxym - wxyp) / 2.0d0 / Zs
          Wgdnv(CHF_IX[i;j;k],11 + cz    ) = rv*(wxzm - wxzp) / 2.0d0 / Zs
          Wgdnv(CHF_IX[i;j;k],11 + cx + 3) = (wxxm + wxxp) / 2.0d0
          Wgdnv(CHF_IX[i;j;k],11 + cy + 3) =  wyy + sxx * lam / (2.0d0 * mu + lam)
          Wgdnv(CHF_IX[i;j;k],11 + cz + 3) =  wzz + sxx * lam / (2.0d0 * mu + lam)
          Wgdnv(CHF_IX[i;j;k],11 + cxy   ) = (wxym + wxyp) / 2.0d0
          Wgdnv(CHF_IX[i;j;k],11 + cxz   ) = (wxzm + wxzp) / 2.0d0
          Wgdnv(CHF_IX[i;j;k],11 + cyz   ) = wyz
          Wgdnv(CHF_IX[i;j;k],11 +  9    ) = (Rlam + Llam) / 2.0d0
          Wgdnv(CHF_IX[i;j;k],11 + 10    ) = (Rgam + Lgam) / 2.0d0
        CHF_ENDDO

        return
        end

C
C       Copy U to W
C
        subroutine COPYF(
     &    CHF_FRA[W],
     &    CHF_CONST_FRA[U],
     &    CHF_BOX[box])

        integer CHF_DDECL[i;j;k]
        integer iv

        do iv = 0,CHF_NCOMP[U] - 1
          CHF_MULTIDO[box;i;j;k]
            W(CHF_IX[i;j;k],iv) = U(CHF_IX[i;j;k],iv)
          CHF_ENDDO
        enddo

        return
        end


C
C       This is a quasilinear update, i.e. A*(wl - wr)
C
        subroutine GETADWDXF(
     &    CHF_FRA[AdWdx],
     &    CHF_CONST_FRA[WHalf],
     &    CHF_CONST_FRA[W],
     &    CHF_CONST_REAL[scale],
     &    CHF_CONST_INT[idir],
     &    CHF_BOX[box])

#include "IBCCommon.fh"

        integer CHF_DDECL[i;j;k]
        integer CHF_DDECL[ioff;joff;koff]
        integer n
        real_t  vx, vy, vz, sxx, syy, szz, sxy, sxz, syz
        real_t rv
        integer cx,cy,cz,cxy,cxz,cyz

        cx = idir
        cy = mod(idir+1,3)
        cz = mod(idir+2,3)

        if (idir .eq. 0) then
          cxy = 6
          cxz = 7
          cyz = 8
          rv  = 1d0
        else if (idir .eq. 1) then
          cxy = 8
          cxz = 6
          cyz = 7
          rv  =-1d0
          !rv  = 1d0
        else
          cxy = 7
          cxz = 8
          cyz = 6
          rv  = 1d0
        endif

        CHF_DTERM[
        ioff = CHF_ID(0,idir);
        joff = CHF_ID(1,idir);
        koff = CHF_ID(2,idir)]

        CHF_MULTIDO[box;i;j;k]
          ! Side 1
          vx  = WHalf(CHF_IX[i+ioff;j+joff;k+koff],cx    )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],cx    )
          vy  = WHalf(CHF_IX[i+ioff;j+joff;k+koff],cy    )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],cy    )
          vz  = WHalf(CHF_IX[i+ioff;j+joff;k+koff],cz    )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],cz    )
          sxx = WHalf(CHF_IX[i+ioff;j+joff;k+koff],cx + 3) 
     &        - WHalf(CHF_IX[i     ;j     ;k     ],cx + 3)
          syy = WHalf(CHF_IX[i+ioff;j+joff;k+koff],cy + 3)
     &        - WHalf(CHF_IX[i     ;j     ;k     ],cy + 3)
          szz = WHalf(CHF_IX[i+ioff;j+joff;k+koff],cz + 3)
     &        - WHalf(CHF_IX[i     ;j     ;k     ],cz + 3)
          sxy = WHalf(CHF_IX[i+ioff;j+joff;k+koff],cxy   )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],cxy   )
          sxz = WHalf(CHF_IX[i+ioff;j+joff;k+koff],cxz   )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],cxz   )
          syz = WHalf(CHF_IX[i+ioff;j+joff;k+koff],cyz   )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],cyz   )

          AdWdx(CHF_IX[i;j;k],cx    ) = -scale * sxx / rho
          AdWdx(CHF_IX[i;j;k],cy    ) = -scale * sxy / rho
          AdWdx(CHF_IX[i;j;k],cz    ) = -scale * sxz / rho
          AdWdx(CHF_IX[i;j;k],cx + 3) = -scale * vx  * (lam + 2.0d0 * mu)
          AdWdx(CHF_IX[i;j;k],cy + 3) = -scale * vx  * lam
          AdWdx(CHF_IX[i;j;k],cz + 3) = -scale * vx  * lam
          AdWdx(CHF_IX[i;j;k],cxy   ) = -scale * vy  * mu
          AdWdx(CHF_IX[i;j;k],cxz   ) = -scale * vz  * mu
          AdWdx(CHF_IX[i;j;k],cyz   ) = -scale * 0d0
          AdWdx(CHF_IX[i;j;k], 9    ) = -scale * 0d0
          AdWdx(CHF_IX[i;j;k],10    ) = -scale * 0d0

          ! Side 2
          vx  = WHalf(CHF_IX[i+ioff;j+joff;k+koff],11 + cx    )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],11 + cx    )
          vy  = WHalf(CHF_IX[i+ioff;j+joff;k+koff],11 + cy    )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],11 + cy    )
          vz  = WHalf(CHF_IX[i+ioff;j+joff;k+koff],11 + cz    )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],11 + cz    )
          sxx = WHalf(CHF_IX[i+ioff;j+joff;k+koff],11 + cx + 3) 
     &        - WHalf(CHF_IX[i     ;j     ;k     ],11 + cx + 3)
          syy = WHalf(CHF_IX[i+ioff;j+joff;k+koff],11 + cy + 3)
     &        - WHalf(CHF_IX[i     ;j     ;k     ],11 + cy + 3)
          szz = WHalf(CHF_IX[i+ioff;j+joff;k+koff],11 + cz + 3)
     &        - WHalf(CHF_IX[i     ;j     ;k     ],11 + cz + 3)
          sxy = WHalf(CHF_IX[i+ioff;j+joff;k+koff],11 + cxy   )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],11 + cxy   )
          sxz = WHalf(CHF_IX[i+ioff;j+joff;k+koff],11 + cxz   )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],11 + cxz   )
          syz = WHalf(CHF_IX[i+ioff;j+joff;k+koff],11 + cyz   )
     &        - WHalf(CHF_IX[i     ;j     ;k     ],11 + cyz   )

          AdWdx(CHF_IX[i;j;k],11 + cx    ) = -rv * scale * sxx / rho
          AdWdx(CHF_IX[i;j;k],11 + cy    ) = -rv * scale * sxy / rho
          AdWdx(CHF_IX[i;j;k],11 + cz    ) = -rv * scale * sxz / rho
          AdWdx(CHF_IX[i;j;k],11 + cx + 3) = -rv * scale * vx  * (lam + 2.0d0 * mu)
          AdWdx(CHF_IX[i;j;k],11 + cy + 3) = -rv * scale * vx  * lam
          AdWdx(CHF_IX[i;j;k],11 + cz + 3) = -rv * scale * vx  * lam
          AdWdx(CHF_IX[i;j;k],11 + cxy   ) = -rv * scale * vy  * mu
          AdWdx(CHF_IX[i;j;k],11 + cxz   ) = -rv * scale * vz  * mu
          AdWdx(CHF_IX[i;j;k],11 + cyz   ) = -rv * scale * 0d0
          AdWdx(CHF_IX[i;j;k],11 +  9    ) = -rv * scale * 0d0
          AdWdx(CHF_IX[i;j;k],11 + 10    ) = -rv * scale * 0d0
        CHF_ENDDO
        return
        end

C
C Set the the boundary flux for a free surface
C
        subroutine LINELASTFREEBCF(
     &    CHF_FRA[Wgdnv],
     &    CHF_CONST_FRA[WInside],
     &    CHF_CONST_FRA[W],
     &    CHF_CONST_INT[lohisign],
     &    CHF_CONST_REAL[dx],
     &    CHF_CONST_INT[idir],
     &    CHF_BOX[box])

#include "IBCCommon.fh"

        integer CHF_DDECL[i;j;k]

        integer cx,cy,cz,cxy,cxz,cyz
        real_t wpx, wpy, wpz
        real_t wmx, wmy, wmz
        real_t sxx, SHF
        real_t rv

        cx = idir
        cy = mod(idir+1,3)
        cz = mod(idir+2,3)

        if (idir .eq. 0) then
          cxy = 6
          cxz = 7
          cyz = 8
          rv  = 1d0
        else if (idir .eq. 1) then
          cxy = 8
          cxz = 6
          cyz = 7
          rv  =-1d0
          !rv  = 1d0
        else
          cxy = 7
          cxz = 8
          cyz = 6
          rv  = 1d0
        endif

        CHF_MULTIDO[box;i;j;k]
          ! Side 1
C         This is a left boundary
C         so we set w+ = -w-
          if (lohisign .eq. -1) then
            wmx = (WInside(CHF_IX[i;j;k],cx + 3) + Zp * WInside(CHF_IX[i;j;k],cx))
            wmy = (WInside(CHF_IX[i;j;k],cxy   ) + Zs * WInside(CHF_IX[i;j;k],cy))
            wmz = (WInside(CHF_IX[i;j;k],cxz   ) + Zs * WInside(CHF_IX[i;j;k],cz))
            wpx = -wmx
            wpy = -wmy
            wpz = -wmz
C         This is a right boundary
C         so we set w- = -w+
          else
            wpx = (WInside(CHF_IX[i;j;k],cx + 3) - Zp * WInside(CHF_IX[i;j;k],cx))
            wpy = (WInside(CHF_IX[i;j;k],cxy   ) - Zs * WInside(CHF_IX[i;j;k],cy))
            wpz = (WInside(CHF_IX[i;j;k],cxz   ) - Zs * WInside(CHF_IX[i;j;k],cz))
            wmx = -wpx
            wmy = -wpy
            wmz = -wpz
          endif
          sxx = (wmx + wpx) / (2.0d0)
          SHF = -(WInside(CHF_IX[i;j;k],cx) - sxx) * lam / (lam + 2.0d0 * mu)
          Wgdnv(CHF_IX[i;j;k],cx    ) = (wmx - wpx) / (2.0d0 * Zp)
          Wgdnv(CHF_IX[i;j;k],cy    ) = (wmy - wpy) / (2.0d0 * Zs)
          Wgdnv(CHF_IX[i;j;k],cz    ) = (wmz - wpz) / (2.0d0 * Zs)
          Wgdnv(CHF_IX[i;j;k],cx + 3) = sxx
          Wgdnv(CHF_IX[i;j;k],cy + 3) = WInside(CHF_IX[i;j;k],cy + 3) + SHF
          Wgdnv(CHF_IX[i;j;k],cz + 3) = WInside(CHF_IX[i;j;k],cz + 3) + SHF
          Wgdnv(CHF_IX[i;j;k],cxy   ) = (wmy + wpy) / (2.0d0)
          Wgdnv(CHF_IX[i;j;k],cxz   ) = (wmz + wpz) / (2.0d0)
          Wgdnv(CHF_IX[i;j;k],cyz   ) = WInside(CHF_IX[i;j;k],cyz  )
          Wgdnv(CHF_IX[i;j;k], 9    ) = WInside(CHF_IX[i;j;k], 9   )
          Wgdnv(CHF_IX[i;j;k],10    ) = WInside(CHF_IX[i;j;k],10   )

          ! Side 2
C         This is a left boundary
C         so we set w+ = -w-
          if (lohisign .eq. -1) then
            wmx = (WInside(CHF_IX[i;j;k],11 + cx + 3) + rv*Zp * WInside(CHF_IX[i;j;k],11 + cx))
            wmy = (WInside(CHF_IX[i;j;k],11 + cxy   ) + rv*Zs * WInside(CHF_IX[i;j;k],11 + cy))
            wmz = (WInside(CHF_IX[i;j;k],11 + cxz   ) + rv*Zs * WInside(CHF_IX[i;j;k],11 + cz))
            wpx = -wmx
            wpy = -wmy
            wpz = -wmz
C         This is a right boundary
C         so we set w- = -w+
          else
            wpx = (WInside(CHF_IX[i;j;k],11 + cx + 3) - rv*Zp * WInside(CHF_IX[i;j;k],11 + cx))
            wpy = (WInside(CHF_IX[i;j;k],11 + cxy   ) - rv*Zs * WInside(CHF_IX[i;j;k],11 + cy))
            wpz = (WInside(CHF_IX[i;j;k],11 + cxz   ) - rv*Zs * WInside(CHF_IX[i;j;k],11 + cz))
            wmx = -wpx
            wmy = -wpy
            wmz = -wpz
          endif
          sxx = (wmx + wpx) / (2.0d0)
          SHF = -(WInside(CHF_IX[i;j;k],11 + cx) - sxx) * lam / (lam + 2.0d0 * mu)
          Wgdnv(CHF_IX[i;j;k],11 + cx    ) = rv*(wmx - wpx) / (2.0d0 * Zp)
          Wgdnv(CHF_IX[i;j;k],11 + cy    ) = rv*(wmy - wpy) / (2.0d0 * Zs)
          Wgdnv(CHF_IX[i;j;k],11 + cz    ) = rv*(wmz - wpz) / (2.0d0 * Zs)
          Wgdnv(CHF_IX[i;j;k],11 + cx + 3) = sxx
          Wgdnv(CHF_IX[i;j;k],11 + cy + 3) = WInside(CHF_IX[i;j;k],11 + cy + 3) + SHF
          Wgdnv(CHF_IX[i;j;k],11 + cz + 3) = WInside(CHF_IX[i;j;k],11 + cz + 3) + SHF
          Wgdnv(CHF_IX[i;j;k],11 + cxy   ) = (wmy + wpy) / (2.0d0)
          Wgdnv(CHF_IX[i;j;k],11 + cxz   ) = (wmz + wpz) / (2.0d0)
          Wgdnv(CHF_IX[i;j;k],11 + cyz   ) = WInside(CHF_IX[i;j;k],11 + cyz  )
          Wgdnv(CHF_IX[i;j;k],11 +  9    ) = WInside(CHF_IX[i;j;k],11 +  9   )
          Wgdnv(CHF_IX[i;j;k],11 + 10    ) = WInside(CHF_IX[i;j;k],11 + 10   )
        CHF_ENDDO

        

        return
        end

C
C Set the the boundary flux for a outflow surface
C
        subroutine LINELASTOUTBCF(
     &    CHF_FRA[Wgdnv],
     &    CHF_CONST_FRA[WInside],
     &    CHF_CONST_FRA[W],
     &    CHF_CONST_INT[lohisign],
     &    CHF_CONST_REAL[dx],
     &    CHF_CONST_INT[idir],
     &    CHF_BOX[box])

#include "IBCCommon.fh"

        integer CHF_DDECL[i;j;k]

        integer cx,cy,cz,cxy,cxz,cyz
        real_t wpx_1, wpy_1, wpz_1
        real_t wmx_1, wmy_1, wmz_1
        real_t wpx_2, wpy_2, wpz_2
        real_t wmx_2, wmy_2, wmz_2
        real_t sxx, SHF
        real_t rv

        cx = idir
        cy = mod(idir+1,3)
        cz = mod(idir+2,3)

        if (idir .eq. 0) then
          cxy = 6
          cxz = 7
          cyz = 8
          rv  = 1d0
        else if (idir .eq. 1) then
          cxy = 8
          cxz = 6
          cyz = 7
          rv  =-1d0
          !rv  = 1d0
        else
          cxy = 7
          cxz = 8
          cyz = 6
          rv  = 1d0
        endif

        ! Side 1
        wpx_1 = background(cx + 3) - Zp * background(cx)
        wpy_1 = background(cxy   ) - Zs * background(cy)
        wpz_1 = background(cxz   ) - Zs * background(cz)

        wmx_1 = background(cx + 3) + Zp * background(cx)
        wmy_1 = background(cxy   ) + Zs * background(cy)
        wmz_1 = background(cxz   ) + Zs * background(cz)

        ! Side 2
        wpx_2 = background(11 + cx + 3) - rv*Zp * background(11 + cx)
        wpy_2 = background(11 + cxy   ) - rv*Zs * background(11 + cy)
        wpz_2 = background(11 + cxz   ) - rv*Zs * background(11 + cz)

        wmx_2 = background(11 + cx + 3) + rv*Zp * background(11 + cx)
        wmy_2 = background(11 + cxy   ) + rv*Zs * background(11 + cy)
        wmz_2 = background(11 + cxz   ) + rv*Zs * background(11 + cz)


        CHF_MULTIDO[box;i;j;k]
          ! Side 1
C         This is a left boundary
          if (lohisign .eq. -1) then
            wmx_1 = (WInside(CHF_IX[i;j;k],cx + 3) + Zp * WInside(CHF_IX[i;j;k],cx))
            wmy_1 = (WInside(CHF_IX[i;j;k],cxy   ) + Zs * WInside(CHF_IX[i;j;k],cy))
            wmz_1 = (WInside(CHF_IX[i;j;k],cxz   ) + Zs * WInside(CHF_IX[i;j;k],cz))
C         This is a right boundary
          else
            wpx_1 = (WInside(CHF_IX[i;j;k],cx + 3) - Zp * WInside(CHF_IX[i;j;k],cx))
            wpy_1 = (WInside(CHF_IX[i;j;k],cxy   ) - Zs * WInside(CHF_IX[i;j;k],cy))
            wpz_1 = (WInside(CHF_IX[i;j;k],cxz   ) - Zs * WInside(CHF_IX[i;j;k],cz))
          endif

          sxx = (wmx_1 + wpx_1) / (2.0d0)
          SHF = -(WInside(CHF_IX[i;j;k],cx) - sxx) * lam / (lam + 2.0d0 * mu)
          Wgdnv(CHF_IX[i;j;k],cx    ) = (wmx_1 - wpx_1) / (2.0d0 * Zp)
          Wgdnv(CHF_IX[i;j;k],cy    ) = (wmy_1 - wpy_1) / (2.0d0 * Zs)
          Wgdnv(CHF_IX[i;j;k],cz    ) = (wmz_1 - wpz_1) / (2.0d0 * Zs)
          Wgdnv(CHF_IX[i;j;k],cx + 3) = sxx
          Wgdnv(CHF_IX[i;j;k],cy + 3) = WInside(CHF_IX[i;j;k],cy + 3) + SHF
          Wgdnv(CHF_IX[i;j;k],cz + 3) = WInside(CHF_IX[i;j;k],cz + 3) + SHF
          Wgdnv(CHF_IX[i;j;k],cxy   ) = (wmy_1 + wpy_1) / (2.0d0)
          Wgdnv(CHF_IX[i;j;k],cxz   ) = (wmz_1 + wpz_1) / (2.0d0)
          Wgdnv(CHF_IX[i;j;k],cyz   ) = WInside(CHF_IX[i;j;k],cyz  )
          Wgdnv(CHF_IX[i;j;k], 9    ) = WInside(CHF_IX[i;j;k], 9   )
          Wgdnv(CHF_IX[i;j;k],10    ) = WInside(CHF_IX[i;j;k],10   )

          ! Side 2
C         This is a left boundary
          if (lohisign .eq. -1) then
            wmx_2 = (WInside(CHF_IX[i;j;k],11 + cx + 3) + rv*Zp * WInside(CHF_IX[i;j;k],11 + cx))
            wmy_2 = (WInside(CHF_IX[i;j;k],11 + cxy   ) + rv*Zs * WInside(CHF_IX[i;j;k],11 + cy))
            wmz_2 = (WInside(CHF_IX[i;j;k],11 + cxz   ) + rv*Zs * WInside(CHF_IX[i;j;k],11 + cz))
C         This is a right boundary
          else
            wpx_2 = (WInside(CHF_IX[i;j;k],11 + cx + 3) - rv*Zp * WInside(CHF_IX[i;j;k],11 + cx))
            wpy_2 = (WInside(CHF_IX[i;j;k],11 + cxy   ) - rv*Zs * WInside(CHF_IX[i;j;k],11 + cy))
            wpz_2 = (WInside(CHF_IX[i;j;k],11 + cxz   ) - rv*Zs * WInside(CHF_IX[i;j;k],11 + cz))
          endif

          sxx = (wmx_2 + wpx_2) / (2.0d0)
          SHF = -(WInside(CHF_IX[i;j;k],11 + cx) - sxx) * lam / (lam + 2.0d0 * mu)
          Wgdnv(CHF_IX[i;j;k],11 + cx    ) = rv*(wmx_2 - wpx_2) / (2.0d0 * Zp)
          Wgdnv(CHF_IX[i;j;k],11 + cy    ) = rv*(wmy_2 - wpy_2) / (2.0d0 * Zs)
          Wgdnv(CHF_IX[i;j;k],11 + cz    ) = rv*(wmz_2 - wpz_2) / (2.0d0 * Zs)
          Wgdnv(CHF_IX[i;j;k],11 + cx + 3) = sxx
          Wgdnv(CHF_IX[i;j;k],11 + cy + 3) = WInside(CHF_IX[i;j;k],11 + cy + 3) + SHF
          Wgdnv(CHF_IX[i;j;k],11 + cz + 3) = WInside(CHF_IX[i;j;k],11 + cz + 3) + SHF
          Wgdnv(CHF_IX[i;j;k],11 + cxy   ) = (wmy_2 + wpy_2) / (2.0d0)
          Wgdnv(CHF_IX[i;j;k],11 + cxz   ) = (wmz_2 + wpz_2) / (2.0d0)
          Wgdnv(CHF_IX[i;j;k],11 + cyz   ) = WInside(CHF_IX[i;j;k],11 + cyz  )
          Wgdnv(CHF_IX[i;j;k],11 +  9    ) = WInside(CHF_IX[i;j;k],11 +  9   )
          Wgdnv(CHF_IX[i;j;k],11 + 10    ) = WInside(CHF_IX[i;j;k],11 + 10   )
        CHF_ENDDO

        return
        end

C
C Set the physical constant parameters
C
        subroutine LINELASTSETF(
     &    CHF_CONST_REAL[aucs],
     &    CHF_CONST_REAL[aucp],
     &    CHF_CONST_REAL[aumu],
     &    CHF_CONST_VR[aback])

#include "IBCCommon.fh"

c
c       physical parameters
c
        cs  = aucs
        cp  = aucp
        mu  = aumu

c
c       other physical (dependent) parameters
c
        rho = mu / (cs**2)
        lam = (cp**2) * rho - two * mu
        Zs  = rho * cs
        Zp  = rho * cp

c
c       Set the background values
c

C       first on side 1
        background( 0) = aback(0)
        background( 1) = aback(1)
        background( 2) = aback(2)
        background( 3) = aback(3)
        background( 4) = aback(4)
        background( 5) = aback(5)
        background( 6) = aback(6)
        background( 7) = aback(7)
        background( 8) = aback(8)
        background( 9) = 0d0
        background(10) = 0d0

C       now on side 2 (it is only the velocities that differ)
C       Currently the difference is only in velocity
        background(11+ 0) = aback(11)
        background(11+ 1) = aback(10)
        background(11+ 2) = aback(11)
        background(11+ 3) = aback(3)
        background(11+ 4) = aback(4)
        background(11+ 5) = aback(5)
        background(11+ 6) = aback(6)
        background(11+ 7) = aback(7)
        background(11+ 8) = aback(8)
        background(11+ 9) = 0d0
        background(11+10) = 0d0

        return
        end

C
C This is a constant initial data
C
        subroutine LEINITF(
     &    CHF_FRA[U],
     &    CHF_CONST_REAL[dx],
     &    CHF_BOX[box])

#include "IBCCommon.fh"

        integer CHF_DDECL[i;j;k]
        real_t CHF_DDECL[x;y;z]
        ! real_t r,val

        CHF_MULTIDO[box;i;j;k]
           ! CHF_DTERM[
           ! x   = (i + half) * dx - 25.0d0;
           ! y   = (j + half) * dx - 25.0d0;
           ! z   = (k + half) * dx - 25.0d0]
           ! r = sqrt(CHF_DTERM[x**2;+y**2;+z**2])
           ! call GAUSSIANFUNC(val,1.0d0,r)
           ! val = val*100


           U(CHF_IX[i;j;k], 0) = background(0)!+val
           U(CHF_IX[i;j;k], 1) = background(1)!+val
           U(CHF_IX[i;j;k], 2) = background(2)!+val
           U(CHF_IX[i;j;k], 3) = background(3)!+val
           U(CHF_IX[i;j;k], 4) = background(4)!+val
           U(CHF_IX[i;j;k], 5) = background(5)!+val
           U(CHF_IX[i;j;k], 6) = background(6)!+val
           U(CHF_IX[i;j;k], 7) = background(7)!+val
           U(CHF_IX[i;j;k], 8) = background(8)!+val
           U(CHF_IX[i;j;k], 9) = 0d0
           U(CHF_IX[i;j;k],10) = 0d0

           U(CHF_IX[i;j;k],11 +  0) = background(11 + 0)
           U(CHF_IX[i;j;k],11 +  1) = background(11 + 1)
           U(CHF_IX[i;j;k],11 +  2) = background(11 + 2)
           U(CHF_IX[i;j;k],11 +  3) = background(11 + 3)
           U(CHF_IX[i;j;k],11 +  4) = background(11 + 4)
           U(CHF_IX[i;j;k],11 +  5) = background(11 + 5)
           U(CHF_IX[i;j;k],11 +  6) = background(11 + 6)
           U(CHF_IX[i;j;k],11 +  7) = background(11 + 7)
           U(CHF_IX[i;j;k],11 +  8) = background(11 + 8)
           U(CHF_IX[i;j;k],11 +  9) = 0d0
           U(CHF_IX[i;j;k],11 + 10) = 0d0

        CHF_ENDDO
        
        return
        end



C
C This is a constant initial data
C
        subroutine LINELASTSETFAB(
     &    CHF_FRA1[U],
     &    CHF_BOX[box],
     &    CHF_CONST_REAL[val])

        integer CHF_DDECL[i;j;k]
        real_t CHF_DDECL[x;y;z]

        CHF_MULTIDO[box;i;j;k]

          U(CHF_IX[i;j;k]) = val

        CHF_ENDDO
        
        return
        end


C
C Gaussian function
C
        subroutine GAUSSIANFUNC(
     &    CHF_REAL[val],
     &    CHF_CONST_REAL[w],
     &    CHF_CONST_REAL[r])

        val = exp(-half*(r/w)**2)

        end

C
C Infinitely smooth transition
C
        subroutine SMOOTHFUNC(
     &    CHF_REAL[val],
     &    CHF_CONST_REAL[w],
     &    CHF_CONST_REAL[r])

        if (r>=w) then
            val = zero
        elseif(r<=0) then
            val = one
        else
            val = exp(r**2/(r**2 - w**2))
        endif
        end

C
C Gaussian function
C
        subroutine SMOOTHBOXCAR(
     &    CHF_REAL[val],
     &    CHF_CONST_REAL[w],
     &    CHF_CONST_REAL[r],
     &    CHF_CONST_REAL[p])

c       val = exp(-(r/w)**p)
        val = 1 - 1/(1+exp(-p*(r-w)))

        end

C
C Box Car
C
        subroutine BOXCARFUNC(
     &    CHF_REAL[val],
     &    CHF_CONST_REAL[w],
     &    CHF_CONST_REAL[r])

        if (r>=w) then
            val = zero
        else
            val = one
        endif
        end

C
C Infinitely smooth transition
C
        subroutine SMOOTHFUNC2(
     &    CHF_REAL[val],
     &    CHF_CONST_REAL[w],
     &    CHF_CONST_REAL[r])


        if (r>=w) then
            val = zero
        elseif(r<=0) then
            val = one
        else
            val = two / (one / exp(r**2/(r**2 - w**2)) + one / (one - exp((r-w)**2/((r-w)**2 - w**2))))
        endif
        end

c
c Smooth Ramp
c
        subroutine SMOOTHRAMP(
     &    CHF_REAL[val],
     &    CHF_REAL[x],
     &    CHF_REAL[k])

        val = half * ( x + log(two * cosh(k * x)) / k)

        end

        subroutine ARTDISP(
     &    CHF_FRA[F],
     &    CHF_CONST_FRA[U],
     &    CHF_CONST_REAL[coeff],
     &    CHF_CONST_INT[idir],
     &    CHF_BOX[box])

        integer CHF_DDECL[i   ; j   ; k   ]
        integer CHF_DDECL[ioff; joff; koff]
        integer iv

        real_t fc,s1,s2

        CHF_DTERM[
        ioff = CHF_ID(0,idir);
        joff = CHF_ID(1,idir);
        koff = CHF_ID(2,idir)]

        do iv = 0,CHF_NCOMP[U] - 1
          CHF_MULTIDO[box;i;j;k]
            fc = F   (CHF_IX[i     ;j     ;k     ],iv)
            s1 = U   (CHF_IX[i     ;j     ;k     ],iv)
            s2 = U   (CHF_IX[i-ioff;j-joff;k-koff],iv)

            F(CHF_IX[i;j;k],iv) = fc - coeff*(s1-s2)
          CHF_ENDDO
        enddo

        return
        end

